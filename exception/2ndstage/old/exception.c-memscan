/*  exception.c

    Initialize the UBC for breakpointing and the 1st_read.bin in memory.
*/

#include "system.h"
#include "serial.h"
#include "util.h"
#include "search.h"
#include "exception.h"
#include "exception-lowlevel.h"

/* The VBR Buffer - we better find out how large VO's actually is */
unsigned char vbr_buffer[3072];

/* Memory Scan:

    Dreamcast System Memory (16MB)
    
    0x8C00'0000 - Main Start
        0x8C000000 - ROM Shadow Start
        0x8C007FFF - ROM Shadow End
        0x8C008000 - IP.BIN Start
        0x8C00FFFF - IP.BIN End
        0x8C010000 - 1ST_READ.BIN Start
    0x8FFF'FFFF - Main End

*/

int calcCRC(const unsigned char *buf, int size)
{
    int i, c, n = 0xffff;
    for (i = 0; i < size; i++)
    {
        n ^= (buf[i]<<8);
        for (c = 0; c < 8; c++)
        {
            if (n & 0x8000)
                n = (n << 1) ^ 4129;
            else
                n = (n << 1);
        }
    }
    return n & 0xffff;
}

void* exception_handler(register_stack *stack)
{
    static char has_init = 0;
    static unsigned int flip_count = 0;

    if (flip_count == (60 * 2) && !has_init)
    {
        ubc_serial_init(57600);
        ubc_serial_flush();

        ubc_serial_write_str("\r\n[UBC] Memory Scan intialization start.\r\n");

        ubc_serial_write_str("[UBC] Memory Scan Ready. Press '!' to alarm.\r\n");

        has_init++;
    }

    /* Every second, check for some input from the serial port. */
    if (!(flip_count % 60) && (ubc_serial_read() != -1))
    {
        unsigned char *mem_start = (void *) 0x8C010000;
        unsigned char *mem_end   = (void *) 0x8FFFFFFF;
        unsigned char *cur_loc;
        unsigned int skip_size = (1024 * 1024);

        for (cur_loc = mem_start; cur_loc < mem_end; cur_loc += skip_size)
        {
            unsigned int size_next_segment;
            char uint_buffer[10];

            uint_to_string((unsigned int) cur_loc, uint_buffer);

            ubc_serial_write_str("[UBC] CRC at 0x");
            ubc_serial_write_str(uint_buffer);
            ubc_serial_write_str(" (");

            if (cur_loc + skip_size > mem_end)
                size_next_segment = mem_end - cur_loc;
            else
                size_next_segment = skip_size;

            uint_to_string(size_next_segment, uint_buffer);
            ubc_serial_write_str(uint_buffer);
            ubc_serial_write_str(") ... ");

            uint_to_string(calcCRC(cur_loc, size_next_segment), uint_buffer);

            ubc_serial_write_str(uint_buffer);
            ubc_serial_write_str("\r\n");
        }
    }

    if (!(flip_count % 60))
    {
        char uint_buffer[10];

        switch (stack->exception_type)
        {
            case EXP_TYPE_GEN:
                ubc_serial_write('G');
                break;

            case EXP_TYPE_CACHE:
                ubc_serial_write('C');
                break;

            case EXP_TYPE_INT:
                ubc_serial_write('I');
                break;
            
            default:
                uint_to_string(stack->exception_type, uint_buffer);
                ubc_serial_write_str(uint_buffer);
                break;
        }
    }

    ubc_serial_flush();
    flip_count++;
    return my_exception_finish;
}
