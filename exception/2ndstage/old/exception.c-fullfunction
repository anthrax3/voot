/*  exception.c

    Handle incoming exceptions in readable C-code.
*/

#include "vars.h"
#include "system.h"
#include "serial.h"
#include "util.h"
#include "exception.h"
#include "exception-lowlevel.h"
#include "rtl8139c.h"

exception_table exp_table;

/* The VBR Buffer - we better find out how large VO's actually is */
uint8 vbr_buffer[VO_VBR_SIZE];
uint8 *vbr_buffer_katana;

static void init_vbr_table(void)
{
    /* STAGE: Be evil to VOOT VBR */
    memcpy(VBR_INT(vbr_buffer) - (interrupt_sub_handler_base - interrupt_sub_handler),
            interrupt_sub_handler,
            interrupt_sub_handler_end - interrupt_sub_handler);

    /* STAGE: Relocate the Katana VBR index */
    vbr_buffer_katana = vbr_buffer + (4 * 2);

    /* STAGE: Flush cache after modifying application memory */
    flush_cache();

    /* STAGE: Change the actual VBR */
    exp_table.vbr_switched = 1;
}

static bool is_vbr_switch_time(void)
{
    return exp_table.ubc_exception_count >= 5;
}

uint32 add_exception_handler(exception_table_entry new)
{
    uint32  index;

    for (index = 0; index < EXP_TABLE_SIZE; index++)
    {
        if(!exp_table.table[index].type)
        {
            exp_table.table[index]=new;
            return index + 1;
        }
    }

    return 0;
}

#define DEBUG

void* exception_handler(register_stack *stack)
{
    uint32 exception_code;
    uint32 index;
    void *back_vector;

#ifdef DEBUG
    ubc_serial_init(57600);
#endif

#ifdef DEBUG
    ubc_serial_write_str("[UBC] Starting exception count segment.\r\n");
#endif

    /* STAGE: Increase our counters and set the proper back_vectors*/
    switch (stack->exception_type)
    {
        case EXP_TYPE_GEN:
            exp_table.general_exception_count++;
            exception_code = *REG_EXPEVT;
            if (exception_code == 0x1e0)    /* Never pass on UBC interrupts to the game */
            {
                exp_table.ubc_exception_count++;
                back_vector = my_exception_finish;
            }
            else
                back_vector = VBR_GEN(vbr_buffer_katana);
            break; 

        case EXP_TYPE_CACHE:
            exp_table.cache_exception_count++;
            exception_code = *REG_EXPEVT;
            back_vector = VBR_CACHE(vbr_buffer_katana);
            break;

        case EXP_TYPE_INT:
            exp_table.interrupt_exception_count++;
            exception_code = *REG_INTEVT;
            back_vector = VBR_INT(vbr_buffer_katana);
            break;

        default:
            exp_table.odd_exception_count++;
            exception_code = EXP_CODE_BAD;
            back_vector = my_exception_finish;
            break;
    }

#ifdef DO_MAIN_CODE

#ifdef DEBUG
    ubc_serial_write_str("[UBC] Finished exception count segment.\r\n");
    ubc_serial_write_str("[UBC] Checking for module init.\r\n");
#endif

    /* STAGE: Handle the first initialization */
    if (!exp_table.vbr_switched && is_vbr_switch_time())
    {
        /* STAGE: Initialize the serial port */
        ubc_serial_init(57600);
        ubc_serial_write_str("[UBC] Initializing modules!\r\n");

        /* ***** PLACE OTHER INITIALIZATION TIME CODE HERE ***** */
        if (pci_detect())
        {
            ubc_serial_write_str("[UBC] PCI found ... attempting intialization.\r\n");
            if (pci_bb_init())
            {
                ubc_serial_write_str("[UBC] BBA found and bridge initialized.\r\n");
                rtl_init();
                ubc_serial_write_str("[UBC] Check your lights, you should have a BBA!\r\n");
            }
            else
                ubc_serial_write_str("[UBC] GAPS glue unable to be initialized.\r\n");
        }
        else
        {
            ubc_serial_write_str("[UBC] No PCI found. Sorry guy.\r\n");
        }

        /* STAGE: Initialize the new VBR */
        init_vbr_table();
    }

#ifdef DEBUG
    ubc_serial_write_str("[UBC] Finished with module init check.\r\n");
    ubc_serial_write_str("[UBC] Handling the exception table.\r\n");
#endif

    /* STAGE: Handle exception table */
    for (index = 0; index < EXP_TABLE_SIZE; index++)
    {
        if (exp_table.table[index].code == exception_code &&
            exp_table.table[index].type == stack->exception_type)
        {
            back_vector = exp_table.table[index].handler(stack, back_vector);
        }
    }

#endif

#ifdef DEBUG
    ubc_serial_write_str("[UBC] Done handling exception table.\r\n");
    ubc_serial_write_str("[UBC] Returning from UBC\r\n");

    ubc_serial_write_str("[UBC] back_vector[0x");
    ubc_serial_write_hex((unsigned) back_vector);
    ubc_serial_write_str("] v_b[0x");
    ubc_serial_write_hex((unsigned int) vbr_buffer);
    ubc_serial_write_str("] mef[0x");
    ubc_serial_write_hex((unsigned int) my_exception_finish);
    ubc_serial_write_str("\r\n");
#endif

    /* STAGE: RETURN */
    return back_vector;
}
