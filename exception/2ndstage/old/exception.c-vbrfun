/*  exception.c

    Initialize the UBC for breakpointing and the 1st_read.bin in memory.
*/

#include "system.h"
#include "serial.h"
#include "util.h"
#include "search.h"
#include "exception.h"
#include "exception-lowlevel.h"

/* The VBR Buffer - we better find out how large VO's actually is */
unsigned char vbr_buffer[3072];

void* exception_handler(register_stack *stack)
{
    unsigned int back_vector;
    static int handled_non = 0;
    static unsigned int gen_count = 0;
    static unsigned int cache_count = 0;
    static unsigned int int_count = 0;
    static unsigned int odd_count = 0;

    ubc_serial_init(57600);

    /* STAGE: Count exceptions */
    switch (stack->exception_type)
    {
        case EXP_TYPE_GEN:
            gen_count++;
            break;

        case EXP_TYPE_CACHE:
            cache_count++;
            break;

        case EXP_TYPE_INT:
            int_count++;
            break;

        default:
            odd_count++;
    }

    /* STAGE: Exception statistics */
    if (!((gen_count + cache_count + int_count + odd_count) % 10000))
    {
        ubc_serial_write_str(" G: 0x");
        ubc_serial_write_hex(gen_count);

        ubc_serial_write_str(" C: 0x");
        ubc_serial_write_hex(cache_count);

        ubc_serial_write_str(" I: 0x");
        ubc_serial_write_hex(int_count);

        ubc_serial_write_str(" O: 0x");
        ubc_serial_write_hex(odd_count);

        ubc_serial_write_str("\r\n");
    }

    /* STAGE: Handle UBC exceptions */
    if (stack->exception_type == EXP_TYPE_GEN && *REG_EXPEVT == 0x1E0)
    {
        /* STAGE: NOTIFY is VBR is at dummy point */
        if (stack->vbr == (unsigned int) vbr_buffer)
        {
            ubc_serial_write_str("[UBC] VBR == Dummy[0x");
            ubc_serial_write_hex(stack->vbr);
            ubc_serial_write_str("]\r\n");
        }

        /* STAGE: Change the VBR to our table */
        if (stack->vbr != (unsigned int) my_vbr_table)
        {
            stack->vbr = (unsigned int) my_vbr_table;

            ubc_serial_write_str("[UBC] VBR = OurTable[0x");
            ubc_serial_write_hex(stack->vbr);
            ubc_serial_write_str("]\r\n");
        }

        back_vector = (unsigned int) my_exception_finish;
    }
    else    /* STAGE: Handle "odd" exceptions */
    {
        /* STAGE: NOTIFY of our first non-UBC exception */
        if (!handled_non)
        {
            ubc_serial_write_str("\r\n[UBC] First non-UBC exception!\r\n");

            handled_non = 1;
        }

        /* STAGE: Give Virtual-On its interrupts */
        switch (stack->exception_type)
        {
            case EXP_TYPE_GEN:
                back_vector = VBR_GEN(vbr_buffer);
                break;

            case EXP_TYPE_CACHE:
                back_vector = VBR_CACHE(vbr_buffer);
                break;

            case EXP_TYPE_INT:
                back_vector = VBR_INT(vbr_buffer);
                break;

            default:
                ubc_serial_write_str("[UBC] Weird exception type 0x");
                ubc_serial_write_hex(stack->exception_type);
                ubc_serial_write_str("\r\n");
                back_vector = (unsigned int) my_exception_finish;
        }
    }

    ubc_serial_write_str("[UBC] BV = 0x");
    ubc_serial_write_hex(back_vector);
    ubc_serial_write_str("\r\n");

    return (void *) back_vector;
}
